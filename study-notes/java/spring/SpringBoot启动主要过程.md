# SpringBoot启动主要过程

-> `SpringApplication.run(Starter.class, args);`  
--> `new SpringApplication(Starter.class)`  
----> `webApplicationType=SERVLET`  
----> 从`SpringFactories`加载`ApplicationContextInitializer`  
----> 从`SpringFactories`加载`ApplicationListener`  
--> `SpringApplication#run(args)` 启动  
----> 从`SpringFactories`加载`SpringApplicationRunListener`  
----> 加载环境配置`ConfigurableEnvironment`  
----> 根据`webApplicationType`创建`ConfigurableApplicationContext` >   `org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext`  
----> `SpringApplication#prepareContext`准备环境  
------> `context.setEnvironment(environment)` 设置环境配置  
------> `SpringApplication#postProcessApplicationContext` 设置上下文  
--------> 判断设置`context` > `beanNameGenerator`, `resourceLoader`  
--------> `if addConversionService is true(default)` 设置`context` > `beanFactory` > `ConversionService`为`ApplicationConversionService`  
------>  `SpringApplication#applyInitializers` 执行`ApplicationContextInitializer`初始化  
------> `listeners.contextPrepared(context)` 监听器  
------>  设置在相同名称不同定义的类注意时是否可以允许覆盖为`allowBeanDefinitionOverriding=false(default)`  
------> `sources = #getAllSource` 加载资源, 整合`primarySources`与`sources`到不可变集合中  
------> `SpringApplication#load(context, sources)` 真正意义上的加载  
--------> `SpringApplication#getBeanDefinitionRegistry(context)` 获取`Bean`注册器  
--------> `loader = SpringApplication#createBeanDefinitionLoader` 创建`Bean`加载器  
----------> 创建`annotatedReader=AnnotatedBeanDefinitionReader`,`xmlReader=XmlBeanDefinitionReader`,`scanner=ClassPathBeanDefinitionScanner`  
--------> 判断设置`loader` > `beanNameGenerator`,`resourceLoader`,`environment`  
--------> `loader#load` 执行加载  
----------> `BeanDefinitionLoader#load(Object)`  
----------> 根据`source`类型`Class/Resource/Package/CharSequence`进行加载 > `Class` > `#load(Class)`  
----------> `#isComponent` 判断是否包括 `Component`注解 ，如果不是 > end  
------------> `AnnotatedBeanDefinitionReader#register(source)`  
--------------> `#doRegisterBean`  
----------------> `abd = new AnnotatedGenericBeanDefinition(source)`  
------------------> `beanCalss = source`  
------------------> `metadata = new StandardAnnotationMetadata(source, true)`  
--------------------> `super(source)` > `StandardClassMetadata` > `introspectedClass=source`  
------------------> `annotations = source#getAnnotations`获取`source`的注解信息  
------------------> `nestedAnnotationsAsMap=true`  
----------------> `AnnotationScopeMetadataResolver#resolveScopeMetadata(abd)` 解析元数据，判断`scopeName`= `singleton`或者`prototype`和`scopedProxyMode`  
----------------> `abd.setScope(scopeName)`  
----------------> `AnnotationBeanNameGenerator#generateBeanName(abd, registry)` 创建`beanName`  
------------------> 如果`abd instanceof AnnotatedBeanDefinition`  
------------------> `#determineBeanNameFromAnnotation`  
--------------------> 判断注解信息中是否有`value`属性，如果有，`beanName=value`  
--------------------> 如果没有`beanName` > `#buildDefaultBeanName` 使用`class`简名称做为`beanName`  
----------------> 处理`abd`的公共注释，如`Lazy`,`DependsOn`,`Role`,`Description`  
----------------> `new BeanDefinitionHolder`  
------------------> 设置`beanDefinition`, `beanName`, `aliases`  
----------------> 根据作用域`scopedProxyMode`设置代理  
----------------> `BeanDefinitionReaderUtils.registerBeanDefinition` 注册`Bean`到`register`中  
------------------> 根据`beanName`和`aliases`注册`Bean`  
------------> 注册成功，返回1  
--------> `loader#load` > `end`  
----> `SpringApplication#refreshContext`  
-----> `SpringApplication#refresh`  
-------> `(AbstractApplicationContext)context#refresh`  
---------> `AbstractApplicationContext#refresh`  
-----------> `AbstractApplicationContext#prepareRefresh` 准备  
-------------> `scanner#clearCache` > `AnnotationConfigServletWebServerApplicationContext`  
-------------> `super#prepareRefresh` > `AbstractApplicationContext`  
---------> `AbstractApplicationContext#obtainFreshBeanFactory` 获取`beanFactory`  
---------> `AbstractApplicationContext#prepareBeanFactory(beanFactory)` 配置`beanFactory`  
---------> `AbstractApplicationContext#postProcessBeanFactory(beanFactory)`  
-----------> `super.postProcessBeanFactory(beanFactory)`  
-------------> `ServletWebServerApplicationContext#postProcessBeanFactory`  
-----------> 如果`basePackage`不空，则调用`scanner#scan` 扫描包  
---------> `AbstractApplicationContext#finishBeanFactoryInitialization(beanFactory)` 开始初始化非懒加载类,祥见[SpringBean加载](./SpringBean加载.md)  
-----> 注册`ShutdownHook`  
